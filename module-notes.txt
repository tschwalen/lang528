# unnamed modules:
This should be super easy.
Just load the module file and compile it in place, passing along the original top level symbol table.
May need to pass context to avoid compiling the main method.


# named modules
Less easy. For compilation, it may need an independent symbol table and generated variables and function 
names must not clash with those of the main module or other imported modules.
Therefore, each module should prefix variables with its own unique string.

Once compilation is complete, the module variable is created.
This consists of generating the code for the symbol table and then creating the module runtime object.
How to do the former? Either a direct intialization list in the main method, generate a special helper
function elsewhere in the file and call that. With initialization lists we may get away with not 
allocating heap memory for strings.

As for runtime behavior, it's simple.
modules can be passed around and used as variables. The main thing to do with them is call index access
on them, which ultimately calls out to their symbol table. Since we already have dynamic function calls
we get a lot of stuff for free. Need to decide what happens when a lookup fails (either runtime error 
or return nothing)